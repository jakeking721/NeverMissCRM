### Intake Submissions
- [TODO] Apply migration `20250903090000_create_intake_submissions.sql` and regenerate types.
  Steps:
    1. From the project root run `supabase db push`.
    2. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
    3. Review `intake_submissions` for any placeholder rows and clear them before launch.
- [TODO] Review existing customers for duplicates after enabling intake submissions.
  Steps:
    1. In Supabase dashboard, check `customers` for duplicate phone or email per user.
    2. Merge or remove any duplicates manually.

### Campaign Form Snapshot
- [TODO] Apply migration `20250902090000_add_form_fields_to_campaigns.sql` and regenerate types.
  Steps:
    1. From the project root run `supabase db push`.
    2. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
    3. Backfill existing `campaigns` rows with the appropriate `form_template_id` or set to NULL; remove any demo forms or slugs.
- [INFO] Campaigns now store a snapshot of the form definition. Updating a form later will not change already-saved snapshots.

### Form Template Refactor
- [TODO] Apply migration `20250901090000_form_template_refactor.sql` and regenerate types.
  Steps:
    1. From the project root run `supabase db push`.
    2. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
    3. Review existing `forms` rows and remove any leftover `slug` or `version` data.

### Schema Specification Alignment
- [TODO] Ensure Supabase database matches the updated `SUPABASE_SCHEMA_SPEC.txt`.
  Steps:
    1. Review the spec and verify all tables, columns, and policies exist in Supabase.
    2. Apply any missing migrations or SQL updates.
    3. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts

### Campaign/Form Schema Migration
- [TODO] Apply new campaign/form schema migration and regenerate types.
  Steps:
    1. From the project root run `supabase db push`.
    2. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
    3. Verify RLS policies allow anonymous form access by campaign slug and restrict all other rows to `auth.uid() = owner_id`.
- [TODO] Replace placeholder QR links and SMS credentials.
  Steps:
    1. Update any sample QR codes or links with the production domain.
    2. Set `VITE_SMS_API_KEY` and `VITE_SMS_API_URL` with real provider values in `.env`.

### Intake Wizard
- [TODO] Add gate settings to `intake_campaigns` table.
  Steps:
    1. In Supabase SQL editor run:
         alter table public.intake_campaigns
           add column gate_field text default 'phone',
           add column prefill_gate boolean default false,
           add column success_message text,
           add column require_consent boolean default false;
    2. Update RLS so only owners read/update; allow anonymous select by slug for wizard.
    3. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
- [TODO] Ensure check-ins set `form_submissions.is_checkin` and allow public insert.
  Steps:
    1. In Supabase SQL editor run:
         alter table public.form_submissions add column if not exists is_checkin boolean default false;
    2. Create policy or RPC permitting anonymous inserts scoped to campaign slug.
    3. Deploy and test the wizard flow.
- [TODO] Configure RLS or create an RPC to allow the wizard to look up customers by phone or email for the campaign owner.
  Steps:
    1. Implement function `intake_find_customer(owner_id uuid, gate text, value text)` returning matching customer id.
    2. Grant execute to anon and ensure policy restricts by owner.
    3. Update wizard service if needed.

### Campaign and Forms Enhancements
- [TODO] Create Supabase `intake_campaigns` table for intake campaign management.
  Steps:
    1. In Supabase SQL editor run:
         create table public.intake_campaigns (
           id uuid primary key default gen_random_uuid(),
           owner_id uuid references auth.users(id),
           title text,
           slug text,
           form_id uuid references campaign_forms(id),
           start_date timestamptz,
           end_date timestamptz,
           status text default 'draft',
           created_at timestamptz default now()
         );
    2. Add unique constraint on (owner_id, slug).
    3. Regenerate Supabase types: supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts

- [TODO] Configure production QR domain for intake campaign links.
  Steps:
    1. Set VITE_PUBLIC_APP_URL to the live domain.
    2. Regenerate any QR codes or links with the new domain.

- [TODO] Replace SMS placeholders with a real provider.
  Steps:
    1. Install and configure provider SDK (e.g., Twilio).
    2. Update src/services/smsService.ts and src/pages/campaigns/SmsList.tsx to use the provider API.
    3. Test sending and tracking messages in a sandbox environment.

- [TODO] Implement form template versioning so saves do not mutate active campaigns.
  Steps:
    1. Add a version column or companion table to campaign_forms.
    2. Update saveForm to insert new versions instead of upserts.
    3. Update any campaign references to lock onto a specific form version.

### Auth Flow and Supabase Setup
- [INFO] Auth flow now relies on Supabase's auth listener for session hydration and refresh.
  Steps:
    1. Sessions are automatically restored on page load; no manual `getSession` calls are needed.
    2. AuthContext updates whenever Supabase emits auth events.

- [TODO] Manual Supabase setup.
  Steps:
    1. Seed at least one admin profile in Supabase:
         update profiles set role = 'admin' where email = '<ADMIN_EMAIL>';
    2. Keep SMS placeholders in `.env` until a real provider is configured:
         VITE_SMS_API_KEY='placeholder'
         VITE_SMS_API_URL='placeholder'

- [TEST] Verify session refresh locally.
  Steps:
    1. Sign in and navigate to a protected page.
    2. In the dev console run `await supabase.auth.refreshSession()` and ensure no error is thrown.
    3. Refresh the browser and confirm the session persists without logging in again.


 - [UPDATED] Registration page now relies on the auth listener for session hydration.
   Steps:
     1. Register a new account with email confirmation disabled.
     2. Confirm redirect to `/dashboard` and that the user session appears without manual refresh.
 - [UPDATED] Dashboard admin credit addition now awaits refresh.
   Steps:
     1. Sign in as an admin and add credits from the dashboard.
     2. Ensure the displayed credit count updates immediately after closing the prompt.

- [NEW] Verify header logout uses AuthContext and clears local placeholders.
  Steps:
    1. Sign in and open the user menu from both desktop and mobile views.
    2. Use the logout option and confirm redirect to the appropriate page and that the session is cleared.
    3. Check browser localStorage to ensure no `sms_log_*` or `customers` keys remain.
- [NEW] Verify login redirect after relying solely on Supabase auth listener.
  Steps:
    1. Sign in with valid credentials and ensure automatic redirect to `/dashboard` occurs without manual page refresh.
    2. Confirm the submit button shows a spinner while the request is pending and that no global loader appears.

- [NEW] Test Login page responsiveness on mobile devices.
  Steps:
    1. Open the login page on phone and tablet browsers.
    2. Verify all inputs and the submit button are visible and easy to interact with without horizontal scrolling.

- [NEW] Validate refactored AuthContext refresh flow and profile timeout.
  Steps:
    1. Sign in and out to ensure `ready` toggles only on real session changes.
    2. Adjust `PROFILE_TIMEOUT_MS` in `src/context/AuthContext.tsx` if profile requests take longer in production.

- [NEW] Apply Supabase migration `20250807100000_update_customers_policies.sql` to enforce approved/active profile checks on all customers policies.
  Steps:
    1. From the project root, run `supabase db push` or execute the SQL in Supabase's SQL editor.
    2. (Optional) Regenerate Supabase types if schema changes:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts

- [NEW] Apply Supabase migration `20250807091000_add_is_admin_function_and_profile_policies.sql` to add `is_admin` helper and tighten `profiles` policies.
  Steps:
    1. From the project root, run `supabase db push` or execute the SQL in Supabase dashboard's SQL editor.
    2. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts

- [NEW] Client-side profile upserts removed; profiles are now auto-created by the Supabase `handle_new_user` trigger.
  Steps:
    1. Ensure migration `20250807090000_add_profile_approval_flags.sql` (defines `handle_new_user`) is applied in Supabase.

- [UPDATED] Admin Users page now orders by and displays the `created_at` field with a fallback to user `id`.
  Steps:
    1. In Supabase SQL editor, backfill missing `created_at` values for existing profiles if any are null:
         update profiles set created_at = inserted_at where created_at is null;
    2. Regenerate Supabase types if the schema changes:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
- [NEW] Add `first_name`, `last_name`, and `zip_code` columns to Supabase `customers` table and migrate legacy data.
  Steps:
    1. In Supabase SQL editor run:
         alter table public.customers add column first_name text not null default '';
         alter table public.customers add column last_name text not null default '';
         alter table public.customers add column zip_code text;
    2. Backfill from existing columns:
         update customers set first_name = split_part(name,' ',1), last_name = trim(split_part(name,' ',2)), zip_code = location;
    3. Drop old `name` and `location` columns when satisfied:
         alter table public.customers drop column name;
         alter table public.customers drop column location;
    4. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
- [NEW] Update `intake_add_customer` RPC to use `p_first_name`, `p_last_name`, and `p_zip_code` parameters.
  Steps:
    1. In Supabase SQL editor, redefine the function with the new parameters inserting into `customers(first_name,last_name,phone,zip_code,extra,user_id)`.
    2. Remove legacy `p_name` and `p_location` usage.
    3. Test by submitting an intake form and verifying row values.
- [NEW] Swap placeholder radar icon in `src/pages/Customers.tsx` with final marketing asset.
  Steps:
    1. Replace the `FiTarget` icon with the chosen graphic.
    2. Adjust styles to match branding.
- [NEW] Apply Supabase migration `20250806080000_add_field_value_upsert_function.sql` to add upsert function for custom field values.
  Steps:
    1. From the project root, run `supabase db push` or execute the SQL in Supabase dashboard.
    2. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
- [NEW] Test new Bulk Import wizard and ensure custom fields appear immediately after import.
  Steps:
    1. Import a CSV using the wizard, creating new fields and mapping existing ones.
    2. Confirm progress bar updates and imported customers show their custom fields in Customers and CustomerDetail pages.
    3. Remove any placeholder/demo customers or fields created during testing.
- [NEW] Verify admin page `PromoteExtraFields` migrates `customers.extra` keys into real custom fields.
  Steps:
    1. Navigate to `/admin/promote-extra-fields` as an admin.
    2. Promote each listed key, selecting the correct type and options.
    3. After promotion, confirm values moved to `customer_custom_field_values` and keys removed from `customers.extra`.

- [NEW] Apply Supabase migration `20250806070000_convert_unique_indexes_to_constraints.sql` to convert unique indexes on customer emails and phones into table constraints.
  Steps:
    1. From the project root, run `supabase db push` or execute the SQL file in Supabase dashboard's SQL editor.
    2. The migration nulls out any remaining duplicate emails or phones. After running, verify no duplicates remain:
         select user_id, email, count(*) from customers group by user_id, email having count(*) > 1;
         select user_id, phone, count(*) from customers group by user_id, phone having count(*) > 1;
    3. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts

- [NEW] Apply Supabase migration `20250806060000_add_credit_functions_and_user_slug.sql` to add credit helper functions and ensure user slugs.
   Steps:
     1. From the project root, run `supabase db push` or execute the SQL in Supabase dashboard's SQL editor.
     2. Regenerate Supabase types:
          supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
     3. For existing users, verify `public_slugs` contains a slug for each user and adjust any duplicates.
- [NEW] Remove obsolete `public_slug` column from Supabase `profiles` table (slugs now stored in `public_slugs`).
  Steps:
    1. In Supabase SQL editor, run:
         alter table public.profiles drop column if exists public_slug;
    2. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
    3. Check Supabase Table editor for any lingering `public_slug` fields and remove them if present.
- [NEW] Backfill customer phone numbers: convert empty strings to NULL and re-normalize.
  Steps:
    1. In Supabase SQL editor, run:
         update customers set phone = null where phone = '';
    2. Re-normalize existing numbers:
         update customers set phone = public.normalize_phone(phone) where phone is not null;
    3. Review any rows with unresolved formatting and fix manually.
- [NEW] Evaluate and optimize new duplicate-handling import flow for performance.
  Steps:
    1. For large CSVs/JSON files, monitor import duration.
    2. Consider server-side stored procedures for batch upserts to reduce round trips.
    3. Remove any placeholder failure CSVs generated during testing.
- [UPDATED] Test revamped CSV import column mapping (now including the Email field) and clean up test data.
  Steps:
    1. Import a CSV with headers such as "first-name" and "email" and confirm they link automatically to matching fields.
    2. Verify selecting an existing field disables the "Create new field" checkbox for that column.
    3. Remove any test customers or custom fields created during the import.
- [NEW] Verify CSV/JSON import preview modals are scrollable and buttons remain reachable on all devices.
  Steps:
    1. Open CSV and JSON import preview modals on desktop and mobile browsers.
    2. Scroll through the content to ensure the Confirm and Cancel buttons are always reachable.
- [NEW] Run `npm install` to fetch the new `libphonenumber-js` dependency and update `package-lock.json`.
  Steps:
    1. From the project root, execute `npm install`.
    2. Commit the updated `package-lock.json` so deployments include the library.
- [NEW] Verify new CustomerDetail page and custom field creation works with Supabase.
  Steps:
    1. Navigate to `/customers/:id` for an existing customer.
    2. Edit base and custom field values, then save and confirm changes appear in Supabase `customers`.
    3. Use "Add Field" to create a custom field; ensure it is stored in `custom_fields` and appears on the page.
    4. Remove any placeholder/demo values before launch.
- [NEW] Confirm missing customer IDs show "Not found" instead of an error.
  Steps:
    1. Navigate to `/customers/{nonexistent-id}` in the app.
    2. Verify the page displays "Not found" without throwing an error.
- [NEW] Verify customer table row navigation and checkbox interactions on mobile devices.
  Steps:
    1. On a physical mobile device, open the Customers page in the deployed app.
    2. Tap a row (excluding the checkbox) to confirm it navigates to the customer detail view.
    3. Tap the row's checkbox and ensure it toggles selection without navigation.

- [NEW] Populate Supabase user metadata with `username`, `credits`, and `role` fields so AuthUser reflects them.
  Steps:
    1. In Supabase Dashboard, open Auth > Users and edit each user's `user_metadata` to include these keys.
    2. Example metadata: `{ "username": "jake", "credits": 100, "role": "admin" }`.
    3. Ask users to sign out and back in so metadata changes propagate to sessions.

- [UPDATED] Apply Supabase migration `20240807120000_rename_visible_on_to_visibleOn.sql` to rename the `custom_fields.visible_on` column to `"visibleOn"`.
  Steps:
    1. From the project root, run `supabase db push` (requires Supabase CLI) or execute the SQL file in Supabase's SQL editor.
    2. Regenerate Supabase types:
        `supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts`

- [NEW] Expand bulk customer edit capabilities introduced in `CustomerEditModal`.
  Steps:
    1. Add richer inputs for select, multiselect, date, and other field types as needed.
    2. Manually verify Supabase updates for each field type and adjust validations.

- [NEW] Replace demo Change Email/Password alerts in `src/pages/Settings.tsx` with real Supabase auth updates.
  Steps:
    1. Use Supabase auth methods to update the user's email and password.
    2. Replace `alert` placeholders with success/error toasts.

- [UPDATED] Verify import preview modals enforce `canConfirm` and busy-state login checks for imports and campaign deletion.
  Steps:
    1. Attempt CSV/JSON import while logged out and confirm the alert prevents the action.
    2. Repeat the import and campaign deletion flows while logged in to ensure they succeed.


- [NEW] Apply Supabase migration `20240717120000_update_campaigns_table.sql` to add campaign scheduling columns and triggers.
  Steps:
    1. Run `supabase db push` or execute the SQL file in Supabase's SQL editor.
    2. Verify `campaigns` now includes `recipients` (text[]), `status`, `scheduled_for`, and the `set_updated_at` trigger.

- [NEW] Apply Supabase migration `20240717121000_add_updated_at_to_customers.sql` to track customer updates.
  Steps:
    1. Run `supabase db push` or execute the SQL in Supabase's SQL editor.
    2. Confirm `customers` table has `updated_at` column and trigger.

- [NEW] Apply Supabase migration `20240717122000_create_credit_ledger.sql` to enable credit history tracking.
  Steps:
    1. Run `supabase db push` or run the SQL file in the Supabase dashboard.
    2. Ensure `credit_ledger` table exists with RLS policy `credit_ledger_owner_rw`.

- [NEW] Regenerate Supabase types in `src/types/supabase.ts` with Supabase CLI output.
  Steps:
    1. Run `supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts`.
    2. Ensure the generated file stays updated with future schema changes.

- [NEW] Reapply migration `20240715120000_add_campaign_forms_and_custom_fields.sql` to fix policy references from `owner_id` to `user_id`.
  Steps:
    1. From the project root, run `supabase db push` or execute the SQL in Supabase's SQL editor.
    2. In the Table editor, confirm policies on `campaign_forms` reference `user_id` and no errors appear.

- [NEW] Apply Supabase migration `20240710120000_create_campaigns_table.sql` to create the `campaigns` table.
  Steps:
    1. From the project root, run `supabase db push` (requires Supabase CLI) or execute the SQL in Supabase dashboard's SQL editor.
    2. In Table editor, confirm `campaigns` has columns `id`, `user_id`, `name`, `message`, timestamps, the index `campaigns_user_id_idx`, and RLS policy `campaigns_owner_rw`.

- [NEW] Apply Supabase migration `20240710130000_create_campaign_templates_table.sql` to create the `campaign_templates` table.
  Steps:
    1. From the project root, run `supabase db push` or run the SQL in Supabase dashboard's SQL editor.
    2. In Table editor, verify `campaign_templates` exists with expected columns, index `campaign_templates_user_id_idx`, and RLS policy `campaign_templates_owner_rw`.

- [NEW] Apply Supabase migration `20240710140000_create_public_slugs_table.sql` to create the `public_slugs` table for public campaign links.
  Steps:
    1. From the project root, run `supabase db push` or execute the SQL in Supabase dashboard's SQL editor.
    2. In Table editor, confirm `public_slugs` has columns `slug`, `user_id`, `created_at`, index `public_slugs_user_id_idx`, and RLS policies `public_slugs_owner_rw` and `public_slugs_public_select`.

- [NEW] Re-run Supabase migration `20240716125959_patch_add_slug_to_campaign_forms.sql` to reset the unique constraint to `(campaign_id, slug)` until `owner_id` is added later.
  Steps:
    1. From the project root, run `supabase db push` (requires Supabase CLI) or execute the SQL in Supabase dashboard's SQL editor.
    2. In Table editor for `campaign_forms`, confirm the constraint `campaign_forms_campaign_id_slug_key` exists and `owner_id` column is still absent.

- [NEW] Apply Supabase migration `20240715120000_add_campaign_forms_and_custom_fields.sql` to ensure `custom_fields` and `campaign_forms` tables and policies are updated safely.
  Steps:
    1. From the project root, run `supabase db push` (requires Supabase CLI) or execute the SQL in the Supabase dashboard's SQL editor.
    2. In Table editor, verify both tables include all expected columns, unique constraints, and row level security policies.
- [NEW] Apply Supabase migration `20250806030000_add_customers_table_and_values.sql` to create `customers` and `customer_custom_field_values` tables.
  Steps:
    1. From the project root, run `supabase db push` (requires Supabase CLI) or run the SQL from that migration in the Supabase dashboard's SQL editor.
    2. In Table editor, confirm both tables exist with RLS policies and the index `customers_user_id_idx`.
- [NEW] Apply Supabase migration `20250806040000_add_intake_function_and_bucket.sql` to create the `intake_add_customer` RPC and ensure the `form-uploads` bucket exists.
  Steps:
    1. From the project root, run `supabase db push` (requires Supabase CLI) or run the SQL from that migration in the Supabase dashboard's SQL editor.
    2. In the SQL editor, verify the RPC `intake_add_customer` accepts parameters (`p_slug`, `p_name`, `p_phone`, `p_location`, `p_extra`, `p_user_id`).
    3. In Supabase Storage, confirm the `form-uploads` bucket is present or created.

- [NEW] Sync updated migrations using `supabase db push` to apply the new `create or replace` policies and `IF NOT EXISTS` constraints.
  Steps:
    1. From the project root, run `supabase db push`.
    2. In Supabase dashboard, verify policies on affected tables (e.g., `campaigns`, `campaign_templates`, `public_slugs`, `custom_fields`, `campaign_forms`, `customers`, and `customer_custom_field_values`) appear without duplicates and constraints exist as expected.
- No manual steps required for removal of placeholder `/* FOOTER */` comment in `src/pages/Home.tsx`.
- No manual steps required for replacing alert dialogs with toast notifications in `src/pages/Customers.tsx` and `src/pages/builder/FormBuilder.tsx`.
- No manual steps required for guarding CSV/JSON import modals behind authentication in `src/pages/Customers.tsx`.
- No manual steps required for exposing Supabase client and env on `window` in dev mode via `src/utils/supabaseClient.ts`.
- No manual steps required for replacing placeholder loading spinner with branded `Loader` in `src/routes/ProtectedRoute.tsx` and `RedirectIfLoggedIn`.
- Replace placeholder hero and patriot banner images in `src/components/home/HeroSection.tsx` and `src/components/home/PatriotBanner.tsx` with production assets. Steps: (1) Upload final images to an assets directory or CDN. (2) Update `HERO_MEDIA` and `PEOPLE_IMG` constants with the new URLs or imports. (3) Run `npm run build` to verify they load correctly.
- Replace the temporary SMS service in `src/services/smsService.ts` with a real provider (e.g., Twilio) and remove `alert` calls and localStorage logging. Ensure the provider is configured to accept E.164-formatted numbers.
- Configure production environment variables for SMS API credentials and scheduling backend.
- [UPDATED] Demo SMS logs are now cleared automatically on logout. Verify no placeholder keys remain before launch.
  Steps:
    1. Log in and perform an action that creates an SMS log or demo customers in localStorage.
    2. Log out via the header or dropdown.
    3. In browser dev tools (Application > Local Storage), confirm `sms_log_*` and `customers` keys are removed.
- Manually verify the new mobile block palette and property panel drawers on multiple real devices and screen sizes, adjusting Tailwind styles if any layout issues arise.
- Test touch drag-and-drop in the form builder on physical iOS/Android browsers to confirm sensors and styles handle mobile gestures.
  - Address npm warning about unknown `http-proxy` env config in deployment environment. Steps: (1) Remove `http-proxy` and `https-proxy` environment variables or rename to `HTTP_PROXY`/`HTTPS_PROXY`. (2) Use `npm config set proxy <url>` if a proxy is required.
  - Remove demo seed scripts (`src/dev/seed.ts` and `src/dev/seed.local.ts`) and delete any sample accounts from production. Steps: (1) Delete scripts. (2) Purge demo users.
- Ensure `.env` variables `VITE_SUPABASE_URL`, `VITE_SUPABASE_ANON_KEY`, and `VITE_PUBLIC_APP_URL` are set to production values (placeholders currently committed). Steps: (1) Edit `.env` with real URLs/keys. (2) Redeploy.
- After integrating a real SMS provider, update `src/utils/credits.ts` `DEFAULT_SMS_COST_PER_SEGMENT` and remove `src/utils/demoSMS.ts`. Steps: (1) Adjust constant to provider rate. (2) Delete file and references.
- Persist credit balance updates to Supabase. Steps: (1) Replace TODOs in `src/utils/credits.ts` with calls to update `profiles.credits`. (2) Confirm RLS policies allow current users to modify their own credits when appropriate.
- Ensure admin accounts have `role='admin'` in `profiles` for access to admin routes. Steps: (1) In Supabase Table editor, set the `role` column to `admin` for desired users. (2) Test navigation to `/admin` as admin and non-admin to confirm guard and Forbidden page work.
- Replace local object URL handling for image and PDF uploads in the form builder with real Supabase storage uploads and persist returned URLs in `schema_json`.
- Verify PDF waiver display styles and acceptance checkbox in production browsers; add backend validation and storage for uploaded files.
- Expand segment builder capabilities with nested groups, range filters for numbers/dates, and a server-side query builder. Steps: (1) Update UI to support grouped rules. (2) Implement filtering logic. (3) Expose backend query endpoint.
- For bulk SMS, add server-side credit enforcement, chunking/rate limiting with retries, and template variable parsing. Steps: (1) Verify credits on backend before sending. (2) Split sends into provider-compliant batches and retry on failures. (3) Parse variables before dispatch.
- Replace simulated credit purchase flow in `creditsService.beginUserPurchase` with a Stripe Checkout session and show transaction history on the billing page. Steps: (1) Create backend to generate Checkout sessions. (2) Redirect users to returned URL. (3) After webhooks update credits, render recent invoices in `src/pages/Settings/Billing.tsx`.
- Implement server-side scheduling, delivery status tracking, and retries for SMS once a provider is integrated. Steps: (1) Use provider API/webhooks to track status. (2) Persist message logs in database. (3) Retry failed sends according to carrier guidelines.
- Improve form builder slug UX. Steps: (1) Enhance slug input to auto-generate/validate unique slugs and prevent duplicates.
  - Confirm Inter font loads in production and host locally if external requests are restricted. Steps: (1) Visit the deployed app and verify the font in browser dev tools. (2) If blocked, download the Inter font files and serve them from the app's assets directory.
- Optional: Allow forms without campaigns. Steps: (1) In the Supabase SQL editor or CLI, run `alter table public.campaign_forms alter column campaign_id drop not null;`. (2) From the project root, execute `supabase db push` to apply the migration. [i did this step, now nullable?]

- [NEW] Verify CSV import works in browsers without Web Crypto support after switch to uuid-based IDs.
  Steps:
    1. Build and deploy the app.
    2. Test Bulk Import in an older browser lacking `crypto.randomUUID` support.
    3. Confirm contact IDs are generated and import succeeds.
- [NEW] Manually verify in Supabase that imported customer rows are associated with the correct `user_id` and remove any placeholder/demo data.
  Steps:
    1. In the Supabase dashboard, open the Table editor for the `customers` table.
    2. Filter by your user ID and ensure each imported row has that `user_id` value.
    3. Delete any placeholder or demo contacts (e.g., rows named "Imported #1" or other sample data).

- [NEW] Verify `intake_add_customer` RPC executes after deployment.
  Steps:
    1. Deploy the updated app.
    2. Submit a test intake form to trigger the RPC.
    3. In Supabase, open the `customers` table and confirm the test row appears with the correct `user_id` and slug.
    4. Delete the test row once verified.

- [NEW] Apply Supabase migration `20250806050000_update_customers_phone_email.sql` for email support and phone normalization.
  Steps:
    1. From the project root, run `supabase db push` or execute the SQL file in Supabase's SQL editor.
    2. Review `customer_email_collisions` and `customer_phone_collisions` tables and resolve any duplicates per `user_id`.
    3. After resolving, delete collision tables and regenerate types: `supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts`.
- [NEW] Grant or revoke admin rights via `profiles.role`.
  Steps:
    1. In Supabase SQL editor run:
         update profiles set role = 'admin' where id = '<USER_ID>';
         update profiles set role = 'user' where id = '<USER_ID>';
- [NEW] Verify RLS policies on `profiles` allow only admins to read/update other profiles.
  Steps:
    1. In Supabase dashboard, open the `profiles` table policies.
    2. Ensure read/update policies include `auth.uid() = id` or `role = 'admin'` and test as both admin and non-admin.
- [NEW] Prep deployment for the new admin guard and Forbidden page.
  Steps:
    1. Seed at least one admin profile using the SQL above.
    2. Remove any temporary admin login links or placeholder data before launch.
    3. Test `/admin` as both admin and non-admin to confirm navigation and Forbidden messaging.
- [NEW] Apply Supabase migration `20250807090000_add_profile_approval_flags.sql` to add approval flags and tighten RLS.
  Steps:
    1. In Supabase SQL editor or via CLI, run the SQL in `supabase/migrations/20250807090000_add_profile_approval_flags.sql`.
    2. Confirm `profiles` has `is_approved`, `is_active`, and `deactivated_at` columns with defaults.
    3. Verify updated policies on `profiles`, `campaigns`, and `customers` enforce admin access and require approved/active profiles for writes.
- [NEW] Regenerate Supabase types after applying the migration.
  Steps:
    1. Execute `supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts`.
    2. Commit the regenerated `src/types/supabase.ts`.
- [NEW] Review new admin user management at `/admin/users`.
  Steps:
    1. As an admin, test Approve/Prohibit/Delete/Make Admin actions and ensure toasts reflect results.
    2. In Supabase dashboard, confirm profile rows update accordingly and remove any test or placeholder accounts.

- [NEW] Review and maintain `SUPABASE_SCHEMA_SPEC.txt` after applying Supabase migrations.
  Steps:
