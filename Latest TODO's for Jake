# Latest TODO's for Jake

Keep this file updated after every code change with any manual steps, placeholder values, or pending integrations.
Whenever the database schema changes, update SUPABASE_SCHEMA_SPEC.txt in tandem and document the required actions here.

### User Settings Column
- [TODO] Add `settings` JSONB column to `profiles` for storing per-user preferences.
  Steps:
    1. In Supabase SQL editor run:
       ```sql
       alter table public.profiles add column if not exists settings jsonb default '{}'::jsonb;
       ```
    2. Regenerate types: `supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts`.
    3. Verify profile RLS policies allow users to update their own `settings` field.

### Zip Radius Filter
- [TODO] Implement server-side zip-code radius filtering for customer queries.
  Steps:
    1. Add or connect to a service that maps zip codes to latitude/longitude.
    2. Extend `customerService.getCustomers` to filter by distance using those coordinates.

### SMS Placeholder Backend
- [TODO] Replace stubbed placeholder expansion in `smsService` with real template parsing once an SMS provider is integrated.
  Steps:
    1. Perform placeholder substitution on the server before dispatching messages.
    2. Validate tokens against allowed field keys to avoid accidental data leaks.

### Intake Submission Latest Values
- [TODO] Apply migration `20251001090000_intake_latest_values.sql` to add `customer_latest_values`, consent audit columns, and the `intake_submit` RPC.
  Steps:
    1. From the project root run `supabase db push` or paste the SQL below into Supabase's SQL editor.
    2. Regenerate types: `supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts`.
    3. Verify RLS policies for `intake_submissions` and `customer_latest_values` in the Supabase dashboard.
  SQL snippet:
    ```sql
    create table if not exists public.customer_latest_values (
      user_id uuid references auth.users(id) not null,
      customer_id uuid references customers(id) on delete cascade,
      data_key text not null,
      value jsonb not null,
      updated_at timestamptz default now(),
      primary key (customer_id, data_key)
    );

    alter table public.customers
      add column if not exists consent_text text,
      add column if not exists consent_collected_at timestamptz;

    create or replace function public.intake_submit(
      p_user_id uuid,
      p_campaign_id uuid,
      p_form_version_id uuid,
      p_answers jsonb,
      p_consent_text text default null
    ) returns uuid
    language plpgsql security definer
    as $$
    declare
      v_sub_id uuid;
      v_cust_id uuid;
      v_phone text := nullif(p_answers->>'f.phone', '');
      v_email text := nullif(p_answers->>'f.email', '');
      v_first text := nullif(p_answers->>'f.first_name', '');
      v_last text := nullif(p_answers->>'f.last_name', '');
      v_zip text := nullif(p_answers->>'f.zip_code', '');
      kv record;
    begin
      insert into intake_submissions(user_id, campaign_id, form_version_id, answers, consent_text)
        values (p_user_id, p_campaign_id, p_form_version_id, p_answers, p_consent_text)
        returning id into v_sub_id;

      if v_phone is not null then
        select id into v_cust_id
        from customers
        where user_id = p_user_id and normalize_phone(phone) = normalize_phone(v_phone)
        limit 1;
      end if;

      if v_cust_id is null and v_email is not null then
        select id into v_cust_id
        from customers
        where user_id = p_user_id and lower(trim(email)) = lower(trim(v_email))
        limit 1;
      end if;

      if v_cust_id is null then
        insert into customers(user_id, first_name, last_name, phone, email, zip_code, consent_text, consent_collected_at)
          values (p_user_id, coalesce(v_first,''), coalesce(v_last,''), v_phone, v_email, v_zip, p_consent_text,
                  case when p_consent_text is not null then now() else null end)
          returning id into v_cust_id;
      else
        update customers set
          first_name = coalesce(v_first, first_name),
          last_name = coalesce(v_last, last_name),
          phone = coalesce(v_phone, phone),
          email = coalesce(v_email, email),
          zip_code = coalesce(v_zip, zip_code),
          consent_text = coalesce(p_consent_text, consent_text),
          consent_collected_at = case when p_consent_text is not null then now() else consent_collected_at end
        where id = v_cust_id;
      end if;

      update intake_submissions set customer_id = v_cust_id where id = v_sub_id;

      for kv in select key, value from jsonb_each(p_answers)
      loop
        if kv.value is null or kv.value::text in ('null','""','[]','{}') then
          continue;
        end if;
        insert into customer_latest_values(user_id, customer_id, data_key, value)
          values (p_user_id, v_cust_id, kv.key, kv.value)
          on conflict (customer_id, data_key)
          do update set value = excluded.value, updated_at = now();
      end loop;

      return v_cust_id;
    end;
    $$;
    ```

- [TODO] Provide real SMS provider credentials (`SMS_API_KEY`, `SMS_API_SECRET`) before launch; placeholders remain.
  Steps:
    1. Acquire credentials from the chosen SMS provider.
    2. Add them to the production environment variables.
    3. Redeploy the app once ready.

### Forms Navigation Adjustment
- [INFO] Removed "Forms" link from the header; access forms via the new "Manage Forms" button on the Intake Campaigns page.
- [TODO] After deployment, navigate to Intake Campaigns and verify the "Manage Forms" button routes to `/forms` and displays correctly on mobile and desktop.

### Intake Campaign Slug Validation
- [INFO] Slug uniqueness check now scoped to the current user in the UI, matching database constraint `(owner_id, slug)`. No manual action required.

### IntakeRenderer footer button
- [INFO] No manual deployment steps required. Rebuild and verify sticky submit button on mobile devices.

### Intake Flow Migration
- [TODO] Apply migration `20250808000000_intake_flow.sql` to create/alter intake tables and RPCs.
  Steps:
    1. From project root run `supabase db push` or execute the SQL in Supabase's SQL editor.
    2. Regenerate types: `supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts`.
    3. Review and adjust RLS policies in Supabase UI if any conflicts arise.
- [TODO] Remove any placeholder campaigns, forms, or submission rows added for testing after verification.
### QR Domain Setup
- [TODO] Set `VITE_QR_BASE_URL` in production environment to the canonical QR domain (e.g., `https://qr.example.com`).
  Steps:
    1. Edit the environment variables for each deployment and add the real QR base URL.
    2. Redeploy the app so QR links use the new domain.
- [TODO] Configure DNS/hosting so the QR domain serves the app and rewrites `/intake/*` to `index.html`.
  Steps:
    1. Point the QR domain's DNS to the hosting provider.
    2. Add a rewrite rule forwarding `/intake/*` requests to the SPA entry.
- [TODO] Set up 301 redirects from any legacy QR domains to the canonical `/intake/:slug` path.
  Steps:
    1. In host or proxy settings, map each legacy host to `https://<QR_DOMAIN>/intake/:slug`.
    2. Verify scanning old QR codes reaches the active campaign.
- [TODO] Regenerate any existing QR codes to use the canonical domain.
  Steps:
    1. In the app, open each campaign and download new QR codes.
    2. Replace printed materials or digital assets with updated codes.
### Intake Campaign Actions Dropdown
- [TODO] Implement submissions view for intake campaigns. Dropdown's "Submissions" item currently navigates to `/campaigns/intake/<id>/submissions` which does not yet exist.
  Steps:
    1. Create the intake campaign submissions route and page.
    2. Ensure the dropdown item navigates correctly once the page is available.
- [TODO] Test QR Code modal copy/download on iOS and Android browsers.
  Steps:
    1. Build the project or run on a physical device.
    2. From Intake Campaigns list, open the actions menu and select "QR Code".
    3. Verify copying the URL and downloading the image works on mobile.



### Form Versioning
- [TODO] Apply migration `20250904110000_create_form_versions_table.sql` to create `form_versions` and update `intake_campaigns`.
  Steps:
    1. From the project root run `supabase db push`.
    2. Regenerate types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
    3. In Supabase, copy existing form schemas into `form_versions` as needed and update `intake_campaigns.form_version_id`/`form_snapshot_json` for active campaigns.
    4. Remove any temporary or placeholder form records once migrated.


### Intake Resolver View
- [TODO] Create `public.intake_resolver` view joining `intake_campaigns` to `form_versions` for anonymous form access.
  Steps:
    1. In the Supabase SQL editor run:

         create or replace view public.intake_resolver as
         select ic.slug,
                ic.id as campaign_id,
                ic.form_version_id as form_version_id,
                coalesce(ic.form_snapshot_json, fv.schema_json) as form_json,
                ic.status,
                ic.start_date,
                ic.end_date,
                ic.owner_id,
                ic.gate_field,
                ic.prefill_gate,
                ic.success_message,
                ic.require_consent
         from intake_campaigns ic
         left join form_versions fv on ic.form_version_id = fv.id;

    2. Grant anonymous read access:

         grant select on public.intake_resolver to anon;

    3. Revoke direct public access to the source tables:

         revoke all on public.intake_campaigns from public;
         revoke all on public.form_versions from public;

    4. Remove public select policies so reads only occur via the view:

         drop policy if exists intake_campaigns_public_select on public.intake_campaigns;
         drop policy if exists form_versions_public_select on public.form_versions;

    5. Regenerate Supabase types after applying the view:

         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts

### Form Save Standardization
- [TODO] Ensure Supabase has `campaign_forms` table with columns `id`, `owner_id`, `title`, `description`, `slug`, `schema_json`, `created_at`, and `updated_at`.
  Steps:
    1. In the Supabase SQL editor run:

         create table if not exists public.campaign_forms (
           id uuid primary key default gen_random_uuid(),
           campaign_id uuid,
           template_id uuid,
           owner_id uuid references auth.users(id) not null default auth.uid(),
           slug text,
           title text not null,
           description text,
           schema_json jsonb default '{}',
           created_at timestamptz default now(),
           updated_at timestamptz default now(),
           unique (owner_id, slug)
         );

    2. Drop legacy `forms` table if present:

         drop table if exists public.forms;

    3. Regenerate Supabase types:

         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
- [TODO] Remove any placeholder rows used for testing from `campaign_forms` before launch.
- [TODO] Verify RLS policies require `auth.uid() = owner_id` on `campaign_forms` and `form_versions`.
  Steps:
    1. In the Supabase dashboard, open each table's **Policies** tab.
    2. Confirm select/insert/update/delete policies check `auth.uid() = owner_id`.
    3. Adjust policies via SQL editor if any are missing or incorrect.
- [TODO] Confirm app requests use `/rest/v1/campaign_forms` and no 404s occur.
  Steps:
    1. Run `npm run dev` and open browser developer tools.
    2. Navigate to the Forms list and builder pages.
    3. Ensure network calls hit `/rest/v1/campaign_forms` and respond with 200; clear any test data.

### Homepage Refresh
- [TODO] Verify simplified global footer renders below the SmallBizBlock on Home and across routes.
  Steps:
    1. Run `npm run dev` or build the project.
    2. Navigate to Home, Bulk Import, and Promote Extra Fields pages.
    3. Confirm the footer shows once with dark background and centered text.
    4. Check legibility and spacing on mobile and desktop.
- [TODO] Replace placeholder flag hero background (`/public/flag-bg.jpg`) with final imagery.
  Steps:
    1. Swap `/public/flag-bg.jpg` with production asset.
    2. Run `npm run build` and verify hero renders correctly.
- [TODO] Swap placeholder visuals in feature bands with final SVGs or media.
  Steps:
    1. Provide final assets for campaign, QR, targeting, and SMS bands.
    2. Update each component to use the assets and confirm marketing text remains accurate.
    3. Rebuild and test responsiveness on mobile and desktop.
  - [TODO] Replace demo QR code link in `src/components/home/FeatureBandQR.tsx` with production intake URL.
    Steps:
      1. Update the `QRCodeSVG` value to the real campaign link.
      2. Rebuild and scan to verify it resolves correctly.
  - [TODO] Replace temporary `react-icons` lucide imports with the `lucide-react` package once dependencies can be installed.
    Steps:
      1. Install `lucide-react` and swap the icon imports in home components.
      2. Rebuild and ensure icons render properly.
  - [TODO] Implement actual demo booking route for hero "Watch Demo" button (currently `/demo`).
  Steps:
    1. Create the demo scheduling page or external link.
    2. Update navigation target and test after deployment.
  - [TODO] Audit homepage for temporary text or placeholder links and replace with final content.

### Intake Submissions
- [TODO] Apply migration `20250903090000_create_intake_submissions.sql` and regenerate types.
  Steps:
    1. From the project root run `supabase db push`.
    2. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
    3. Review `intake_submissions` for any placeholder rows and clear them before launch.
- [NEW] Apply migration `20250904120000_add_form_version_id_to_intake_submissions.sql` to add `form_version_id` and stricter insert policy.
  Steps:
    1. From the project root run `supabase db push`.
    2. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
    3. Confirm anonymous inserts only succeed for campaigns with `status = 'active'` and current date within `start_date`/`end_date`.
    4. Remove any test submissions that reference placeholder form versions.
- [TODO] Review existing customers for duplicates after enabling intake submissions.
  Steps:
    1. In Supabase dashboard, check `customers` for duplicate phone or email per user.
    2. Merge or remove any duplicates manually.

### Customer Schema Cleanup
- [TODO] Apply migration `20250904090000_update_customers_created_at_and_name_split.sql` and regenerate types.
  Steps:
    1. From the project root run `supabase db push`.
    2. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
    3. Review existing customers for proper first/last names and remove any leftover `name` or `location` data.

### Campaign Schema Cleanup
- [TODO] Apply migration `20250904091000_cleanup_campaigns_drop_scheduled_for.sql` and regenerate types.
  Steps:
    1. From the project root run `supabase db push`.
    2. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
    3. Confirm `campaigns` no longer has `scheduled_for` and existing rows use `start_at` / `end_at`.

### Campaign Form Snapshot
- [TODO] Apply migration `20250902090000_add_form_fields_to_campaigns.sql` and regenerate types.
  Steps:
    1. From the project root run `supabase db push`.
    2. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
    3. Backfill existing `campaigns` rows with the appropriate `form_template_id` or set to NULL; remove any demo forms or slugs.
- [INFO] Campaigns now store a snapshot of the form definition. Updating a form later will not change already-saved snapshots.

### Form Template Refactor
- [TODO] Apply migration `20250901090000_form_template_refactor.sql` and regenerate types.
  Steps:
    1. From the project root run `supabase db push`.
    2. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
    3. Review existing `forms` rows and remove any leftover `slug` or `version` data.

### Schema Specification Alignment
- [TODO] Ensure Supabase database matches the updated `SUPABASE_SCHEMA_SPEC.txt`.
  Steps:
    1. Review the spec and verify all tables, columns, and policies exist in Supabase.
    2. Apply any missing migrations or SQL updates.
    3. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts

### Campaign/Form Schema Migration
- [TODO] Apply new campaign/form schema migration and regenerate types.
  Steps:
    1. From the project root run `supabase db push`.
    2. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
    3. Verify RLS policies allow anonymous form access by campaign slug and restrict all other rows to `auth.uid() = owner_id`.
- [TODO] Replace placeholder QR links and SMS credentials.
  Steps:
    1. Update any sample QR codes or links with the production domain.
    2. Set `VITE_SMS_API_KEY` and `VITE_SMS_API_URL` with real provider values in `.env`.

### Intake Wizard
- [TODO] Add gate settings to `intake_campaigns` table.
  Steps:
    1. In Supabase SQL editor run:
         alter table public.intake_campaigns
           add column gate_field text default 'phone',
           add column prefill_gate boolean default false,
           add column success_message text,
           add column require_consent boolean default false;
    2. Update RLS so only owners read/update; allow anonymous select by slug for wizard.
    3. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
- [TODO] Ensure check-ins set `form_submissions.is_checkin` and allow public insert.
  Steps:
    1. In Supabase SQL editor run:
         alter table public.form_submissions add column if not exists is_checkin boolean default false;
    2. Create policy or RPC permitting anonymous inserts scoped to campaign slug.
    3. Deploy and test the wizard flow.
- [TODO] Configure RLS or create an RPC to allow the wizard to look up customers by phone or email for the campaign owner.
  Steps:
    1. Implement function `intake_find_customer(owner_id uuid, gate text, value text)` returning matching customer id.
    2. Grant execute to anon and ensure policy restricts by owner.
    3. Update wizard service if needed.

### Campaign and Forms Enhancements
- [TODO] Create Supabase `intake_campaigns` table for intake campaign management.
  Steps:
    1. In Supabase SQL editor run:
         create table public.intake_campaigns (
           id uuid primary key default gen_random_uuid(),
           owner_id uuid references auth.users(id),
           title text,
           slug text,
           form_id uuid references campaign_forms(id),
           start_date timestamptz,
           end_date timestamptz,
           status text default 'draft',
           created_at timestamptz default now()
         );
    2. Add unique constraint on (owner_id, slug).
    3. Regenerate Supabase types: supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts

- [TODO] Configure production QR domain for intake campaign links.
  Steps:
    1. Set VITE_PUBLIC_APP_URL to the live domain.
    2. Regenerate any QR codes or links with the new domain.

- [TODO] Replace SMS placeholders with a real provider.
  Steps:
    1. Install and configure provider SDK (e.g., Twilio).
    2. Update src/services/smsService.ts and src/pages/campaigns/SmsList.tsx to use the provider API.
    3. Test sending and tracking messages in a sandbox environment.

- [TODO] Backfill legacy intake campaigns missing `form_id` and verify public select policies.
  Steps:
    1. In Supabase SQL editor, run a one-time update to resolve any `intake_campaigns` rows that stored a form slug:

         update intake_campaigns ic
           set form_id = cf.id
         from campaign_forms cf
         where ic.form_id is null and ic.slug = cf.slug;

    2. Ensure policy `intake_campaigns_public_select` permits anonymous read by slug and returns `id`, `owner_id`, `form_snapshot_json`, and `form_id`.
    3. Confirm `campaign_forms_public_select` only exposes published forms; add a `published boolean default true` column if missing and adjust policy accordingly.
    4. After applying changes, test creating a form, attaching it to an intake campaign, editing the campaign, and loading `/intake/:slug`.

- [TODO] Implement form template versioning so saves do not mutate active campaigns.
  Steps:
    1. Add a version column or companion table to campaign_forms.
    2. Update saveForm to insert new versions instead of upserts.
    3. Update any campaign references to lock onto a specific form version.

### Auth Flow and Supabase Setup
- [INFO] Auth flow now relies on Supabase's auth listener for session hydration and refresh.
  Steps:
    1. Sessions are automatically restored on page load; no manual `getSession` calls are needed.
    2. AuthContext updates whenever Supabase emits auth events.

- [TODO] Manual Supabase setup.
  Steps:
    1. Seed at least one admin profile in Supabase:
         update profiles set role = 'admin' where email = '<ADMIN_EMAIL>';
    2. Keep SMS placeholders in `.env` until a real provider is configured:
         VITE_SMS_API_KEY='placeholder'
         VITE_SMS_API_URL='placeholder'

- [TEST] Verify session refresh locally.
  Steps:
    1. Sign in and navigate to a protected page.
    2. In the dev console run `await supabase.auth.refreshSession()` and ensure no error is thrown.
    3. Refresh the browser and confirm the session persists without logging in again.


 - [UPDATED] Registration page now relies on the auth listener for session hydration.
   Steps:
     1. Register a new account with email confirmation disabled.
     2. Confirm redirect to `/dashboard` and that the user session appears without manual refresh.
 - [UPDATED] Dashboard admin credit addition now awaits refresh.
   Steps:
     1. Sign in as an admin and add credits from the dashboard.
     2. Ensure the displayed credit count updates immediately after closing the prompt.

- [NEW] Verify header logout uses AuthContext and clears local placeholders.
  Steps:
    1. Sign in and open the user menu from both desktop and mobile views.
    2. Use the logout option and confirm redirect to the appropriate page and that the session is cleared.
    3. Check browser localStorage to ensure no `sms_log_*` or `customers` keys remain.
- [NEW] Verify login redirect after relying solely on Supabase auth listener.
  Steps:
    1. Sign in with valid credentials and ensure automatic redirect to `/dashboard` occurs without manual page refresh.
    2. Confirm the submit button shows a spinner while the request is pending and that no global loader appears.

- [NEW] Test Login page responsiveness on mobile devices.
  Steps:
    1. Open the login page on phone and tablet browsers.
    2. Verify all inputs and the submit button are visible and easy to interact with without horizontal scrolling.

- [NEW] Validate refactored AuthContext refresh flow and profile timeout.
  Steps:
    1. Sign in and out to ensure `ready` toggles only on real session changes.
    2. Adjust `PROFILE_TIMEOUT_MS` in `src/context/AuthContext.tsx` if profile requests take longer in production.

- [NEW] Apply Supabase migration `20250807100000_update_customers_policies.sql` to enforce approved/active profile checks on all customers policies.
  Steps:
    1. From the project root, run `supabase db push` or execute the SQL in Supabase's SQL editor.
    2. (Optional) Regenerate Supabase types if schema changes:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts

- [NEW] Apply Supabase migration `20250807091000_add_is_admin_function_and_profile_policies.sql` to add `is_admin` helper and tighten `profiles` policies.
  Steps:
    1. From the project root, run `supabase db push` or execute the SQL in Supabase dashboard's SQL editor.
    2. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts

- [NEW] Client-side profile upserts removed; profiles are now auto-created by the Supabase `handle_new_user` trigger.
  Steps:
    1. Ensure migration `20250807090000_add_profile_approval_flags.sql` (defines `handle_new_user`) is applied in Supabase.

- [UPDATED] Admin Users page now orders by and displays the `created_at` field with a fallback to user `id`.
  Steps:
    1. In Supabase SQL editor, backfill missing `created_at` values for existing profiles if any are null:
         update profiles set created_at = inserted_at where created_at is null;
    2. Regenerate Supabase types if the schema changes:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
- [NEW] Swap placeholder radar icon in `src/pages/Customers.tsx` with final marketing asset.
  Steps:
    1. Replace the `FiTarget` icon with the chosen graphic.
    2. Adjust styles to match branding.
- [NEW] Apply Supabase migration `20250806080000_add_field_value_upsert_function.sql` to add upsert function for custom field values.
  Steps:
    1. From the project root, run `supabase db push` or execute the SQL in Supabase dashboard.
    2. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
- [NEW] Test new Bulk Import wizard and ensure custom fields appear immediately after import.
  Steps:
    1. Import a CSV using the wizard, creating new fields and mapping existing ones.
    2. Confirm progress bar updates and imported customers show their custom fields in Customers and CustomerDetail pages.
    3. Remove any placeholder/demo customers or fields created during testing.
- [NEW] Verify admin page `PromoteExtraFields` migrates `customers.extra` keys into real custom fields.
  Steps:
    1. Navigate to `/admin/promote-extra-fields` as an admin.
    2. Promote each listed key, selecting the correct type and options.
    3. After promotion, confirm values moved to `customer_custom_field_values` and keys removed from `customers.extra`.

- [NEW] Apply Supabase migration `20250806070000_convert_unique_indexes_to_constraints.sql` to convert unique indexes on customer emails and phones into table constraints.
  Steps:
    1. From the project root, run `supabase db push` or execute the SQL file in Supabase dashboard's SQL editor.
    2. The migration nulls out any remaining duplicate emails or phones. After running, verify no duplicates remain:
         select user_id, email, count(*) from customers group by user_id, email having count(*) > 1;
         select user_id, phone, count(*) from customers group by user_id, phone having count(*) > 1;
    3. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts

- [NEW] Apply Supabase migration `20250806060000_add_credit_functions_and_user_slug.sql` to add credit helper functions and ensure user slugs.
   Steps:
     1. From the project root, run `supabase db push` or execute the SQL in Supabase dashboard's SQL editor.
     2. Regenerate Supabase types:
          supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
     3. For existing users, verify `public_slugs` contains a slug for each user and adjust any duplicates.
- [NEW] Remove obsolete `public_slug` column from Supabase `profiles` table (slugs now stored in `public_slugs`).
  Steps:
    1. In Supabase SQL editor, run:
         alter table public.profiles drop column if exists public_slug;
    2. Regenerate Supabase types:
         supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts
    3. Check Supabase Table editor for any lingering `public_slug` fields and remove them if present.
- [NEW] Backfill customer phone numbers: convert empty strings to NULL and re-normalize.
  Steps:
    1. In Supabase SQL editor, run:
         update customers set phone = null where phone = '';
    2. Re-normalize existing numbers:
         update customers set phone = public.normalize_phone(phone) where phone is not null;
    3. Review any rows with unresolved formatting and fix manually.
- [NEW] Evaluate and optimize new duplicate-handling import flow for performance.
  Steps:
    1. For large CSVs/JSON files, monitor import duration.
    2. Consider server-side stored procedures for batch upserts to reduce round trips.
    3. Remove any placeholder failure CSVs generated during testing.
- [UPDATED] Test revamped CSV import column mapping (now including the Email field) and clean up test data.
  Steps:
    1. Import a CSV with headers such as "first-name" and "email" and confirm they link automatically to matching fields.
    2. Verify selecting an existing field disables the "Create new field" checkbox for that column.
    3. Remove any test customers or custom fields created during the import.
- [NEW] Verify CSV/JSON import preview modals are scrollable and buttons remain reachable on all devices.
  Steps:
    1. Open CSV and JSON import preview modals on desktop and mobile browsers.
    2. Scroll through the content to ensure the Confirm and Cancel buttons are always reachable.
- [NEW] Run `npm install` to fetch the new `libphonenumber-js` dependency and update `package-lock.json`.
  Steps:
    1. From the project root, execute `npm install`.
    2. Commit the updated `package-lock.json` so deployments include the library.
- [NEW] Verify new CustomerDetail page and custom field creation works with Supabase.
  Steps:
    1. Navigate to `/customers/:id` for an existing customer.
    2. Edit base and custom field values, then save and confirm changes appear in Supabase `customers`.
    3. Use "Add Field" to create a custom field; ensure it is stored in `custom_fields` and appears on the page.
    4. Remove any placeholder/demo values before launch.
- [NEW] Confirm missing customer IDs show "Not found" instead of an error.
  Steps:
    1. Navigate to `/customers/{nonexistent-id}` in the app.
    2. Verify the page displays "Not found" without throwing an error.
- [NEW] Verify customer table row navigation and checkbox interactions on mobile devices.
  Steps:
    1. On a physical mobile device, open the Customers page in the deployed app.
    2. Tap a row (excluding the checkbox) to confirm it navigates to the customer detail view.
    3. Tap the row's checkbox and ensure it toggles selection without navigation.

- [NEW] Populate Supabase user metadata with `username`, `credits`, and `role` fields so AuthUser reflects them.
  Steps:
    1. In Supabase Dashboard, open Auth > Users and edit each user's `user_metadata` to include these keys.
    2. Example metadata: `{ "username": "jake", "credits": 100, "role": "admin" }`.
    3. Ask users to sign out and back in so metadata changes propagate to sessions.

- [UPDATED] Apply Supabase migration `20240807120000_rename_visible_on_to_visibleOn.sql` to rename the `custom_fields.visible_on` column to `"visibleOn"`.
  Steps:
    1. From the project root, run `supabase db push` (requires Supabase CLI) or execute the SQL file in Supabase's SQL editor.
    2. Regenerate Supabase types:
        `supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts`

- [NEW] Expand bulk customer edit capabilities introduced in `CustomerEditModal`.
  Steps:
    1. Add richer inputs for select, multiselect, date, and other field types as needed.
    2. Manually verify Supabase updates for each field type and adjust validations.

- [NEW] Replace demo Change Email/Password alerts in `src/pages/Settings.tsx` with real Supabase auth updates.
  Steps:
    1. Use Supabase auth methods to update the user's email and password.
    2. Replace `alert` placeholders with success/error toasts.

- [UPDATED] Verify import preview modals enforce `canConfirm` and busy-state login checks for imports and campaign deletion.
  Steps:
    1. Attempt CSV/JSON import while logged out and confirm the alert prevents the action.
    2. Repeat the import and campaign deletion flows while logged in to ensure they succeed.


- [NEW] Apply Supabase migration `20240717120000_update_campaigns_table.sql` to add campaign scheduling columns and triggers.
  Steps:
    1. Run `supabase db push` or execute the SQL file in Supabase's SQL editor.
      2. Verify `campaigns` now includes `recipients` (text[]), `status`, `start_at`, `end_at`, and the `set_updated_at` trigger.

- [NEW] Apply Supabase migration `20240717121000_add_updated_at_to_customers.sql` to track customer updates.
  Steps:
    1. Run `supabase db push` or execute the SQL in Supabase's SQL editor.
    2. Confirm `customers` table has `updated_at` column and trigger.

- [NEW] Apply Supabase migration `20240717122000_create_credit_ledger.sql` to enable credit history tracking.
  Steps:
    1. Run `supabase db push` or run the SQL file in the Supabase dashboard.
    2. Ensure `credit_ledger` table exists with RLS policy `credit_ledger_owner_rw`.

- [NEW] Regenerate Supabase types in `src/types/supabase.ts` with Supabase CLI output.
  Steps:
    1. Run `supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts`.
    2. Ensure the generated file stays updated with future schema changes.

- [NEW] Reapply migration `20240715120000_add_campaign_forms_and_custom_fields.sql` to fix policy references from `owner_id` to `user_id`.
  Steps:
    1. From the project root, run `supabase db push` or execute the SQL in Supabase's SQL editor.
    2. In the Table editor, confirm policies on `campaign_forms` reference `user_id` and no errors appear.

- [NEW] Apply Supabase migration `20240710120000_create_campaigns_table.sql` to create the `campaigns` table.
  Steps:
    1. From the project root, run `supabase db push` (requires Supabase CLI) or execute the SQL in Supabase dashboard's SQL editor.
    2. In Table editor, confirm `campaigns` has columns `id`, `user_id`, `name`, `message`, timestamps, the index `campaigns_user_id_idx`, and RLS policy `campaigns_owner_rw`.

- [NEW] Apply Supabase migration `20240710130000_create_campaign_templates_table.sql` to create the `campaign_templates` table.
  Steps:
    1. From the project root, run `supabase db push` or run the SQL in Supabase dashboard's SQL editor.
    2. In Table editor, verify `campaign_templates` exists with expected columns, index `campaign_templates_user_id_idx`, and RLS policy `campaign_templates_owner_rw`.

- [NEW] Apply Supabase migration `20240710140000_create_public_slugs_table.sql` to create the `public_slugs` table for public campaign links.
  Steps:
    1. From the project root, run `supabase db push` or execute the SQL in Supabase dashboard's SQL editor.
    2. In Table editor, confirm `public_slugs` has columns `slug`, `user_id`, `created_at`, index `public_slugs_user_id_idx`, and RLS policies `public_slugs_owner_rw` and `public_slugs_public_select`.

- [NEW] Re-run Supabase migration `20240716125959_patch_add_slug_to_campaign_forms.sql` to reset the unique constraint to `(campaign_id, slug)` until `owner_id` is added later.
  Steps:
    1. From the project root, run `supabase db push` (requires Supabase CLI) or execute the SQL in Supabase dashboard's SQL editor.
    2. In Table editor for `campaign_forms`, confirm the constraint `campaign_forms_campaign_id_slug_key` exists and `owner_id` column is still absent.

- [NEW] Apply Supabase migration `20240715120000_add_campaign_forms_and_custom_fields.sql` to ensure `custom_fields` and `campaign_forms` tables and policies are updated safely.
  Steps:
    1. From the project root, run `supabase db push` (requires Supabase CLI) or execute the SQL in the Supabase dashboard's SQL editor.
    2. In Table editor, verify both tables include all expected columns, unique constraints, and row level security policies.
- [NEW] Apply Supabase migration `20250806030000_add_customers_table_and_values.sql` to create `customers` and `customer_custom_field_values` tables.
  Steps:
    1. From the project root, run `supabase db push` (requires Supabase CLI) or run the SQL from that migration in the Supabase dashboard's SQL editor.
    2. In Table editor, confirm both tables exist with RLS policies and the index `customers_user_id_idx`.
- [NEW] Apply Supabase migration `20250806040000_add_intake_function_and_bucket.sql` to create the `intake_add_customer` RPC and ensure the `form-uploads` bucket exists.
  Steps:
    1. From the project root, run `supabase db push` (requires Supabase CLI) or run the SQL from that migration in the Supabase dashboard's SQL editor.
    2. In the SQL editor, verify the RPC `intake_add_customer` accepts parameters (`p_slug`, `p_name`, `p_phone`, `p_location`, `p_extra`, `p_user_id`).
    3. In Supabase Storage, confirm the `form-uploads` bucket is present or created.

- [NEW] Sync updated migrations using `supabase db push` to apply the new `create or replace` policies and `IF NOT EXISTS` constraints.
  Steps:
    1. From the project root, run `supabase db push`.
    2. In Supabase dashboard, verify policies on affected tables (e.g., `campaigns`, `campaign_templates`, `public_slugs`, `custom_fields`, `campaign_forms`, `customers`, and `customer_custom_field_values`) appear without duplicates and constraints exist as expected.
- No manual steps required for removal of placeholder `/* FOOTER */` comment in `src/pages/Home.tsx`.
- No manual steps required for replacing alert dialogs with toast notifications in `src/pages/Customers.tsx` and `src/pages/builder/FormBuilder.tsx`.
- No manual steps required for guarding CSV/JSON import modals behind authentication in `src/pages/Customers.tsx`.
- No manual steps required for exposing Supabase client and env on `window` in dev mode via `src/utils/supabaseClient.ts`.
- No manual steps required for replacing placeholder loading spinner with branded `Loader` in `src/routes/ProtectedRoute.tsx` and `RedirectIfLoggedIn`.
- Replace `/public/flag-bg.jpg` placeholder hero image used in `src/components/home/HeroSection.tsx`. Steps: (1) Replace the file with final imagery or update `HERO_FLAG` to point to the new asset. (2) Run `npm run build` to ensure the hero renders correctly.
- Replace mock QR/phone/radar/chat visuals in feature bands (`src/components/home/FeatureBandCampaign.tsx`, `FeatureBandQR.tsx`, `FeatureBandTargeting.tsx`, `FeatureBandSms.tsx`). Steps: (1) Supply final SVGs or images for each placeholder `div` with `text-6xl md:text-7xl`. (2) Update the components to use the new visuals. (3) Rebuild and verify responsive layout on desktop and mobile.
- Audit and replace placeholder marketing copy or routes. Steps: (1) Search for placeholders such as `/demo` or filler text across `src/components/home` and related routes. (2) Update to final copy and links. (3) Run `npm run build` and navigate to updated routes to confirm they work.
- Implement actual demo booking route for hero "Watch Demo" button (currently `/demo`). Steps: (1) Create the demo scheduling page or external link. (2) Update navigation target. (3) Test navigation after deployment.
- Replace the temporary SMS service in `src/services/smsService.ts` with a real provider (e.g., Twilio) and remove `alert` calls and localStorage logging. Ensure the provider is configured to accept E.164-formatted numbers.
- Configure production environment variables for SMS API credentials and scheduling backend.
- After SMS API integration, verify related routes. Steps: (1) Navigate to `/campaigns` â†’ `SmsList` and other SMS pages after configuring provider credentials. (2) Send a test message to confirm API connectivity. (3) Monitor console/network logs for errors.
- [UPDATED] Demo SMS logs are now cleared automatically on logout. Verify no placeholder keys remain before launch.
  Steps:
    1. Log in and perform an action that creates an SMS log or demo customers in localStorage.
    2. Log out via the header or dropdown.
    3. In browser dev tools (Application > Local Storage), confirm `sms_log_*` and `customers` keys are removed.
- Manually verify the new mobile block palette and property panel drawers on multiple real devices and screen sizes, adjusting Tailwind styles if any layout issues arise.
- Test touch drag-and-drop in the form builder on physical iOS/Android browsers to confirm sensors and styles handle mobile gestures.
  - Address npm warning about unknown `http-proxy` env config in deployment environment. Steps: (1) Remove `http-proxy` and `https-proxy` environment variables or rename to `HTTP_PROXY`/`HTTPS_PROXY`. (2) Use `npm config set proxy <url>` if a proxy is required.
  - Remove demo seed scripts (`src/dev/seed.ts` and `src/dev/seed.local.ts`) and delete any sample accounts from production. Steps: (1) Delete scripts. (2) Purge demo users.
- Ensure `.env` variables `VITE_SUPABASE_URL`, `VITE_SUPABASE_ANON_KEY`, and `VITE_PUBLIC_APP_URL` are set to production values (placeholders currently committed). Steps: (1) Edit `.env` with real URLs/keys. (2) Redeploy.
- After integrating a real SMS provider, update `src/utils/credits.ts` `DEFAULT_SMS_COST_PER_SEGMENT` and remove `src/utils/demoSMS.ts`. Steps: (1) Adjust constant to provider rate. (2) Delete file and references.
- Persist credit balance updates to Supabase. Steps: (1) Replace TODOs in `src/utils/credits.ts` with calls to update `profiles.credits`. (2) Confirm RLS policies allow current users to modify their own credits when appropriate.
- Ensure admin accounts have `role='admin'` in `profiles` for access to admin routes. Steps: (1) In Supabase Table editor, set the `role` column to `admin` for desired users. (2) Test navigation to `/admin` as admin and non-admin to confirm guard and Forbidden page work.
- Replace local object URL handling for image and PDF uploads in the form builder with real Supabase storage uploads and persist returned URLs in `schema_json`.
- Verify PDF waiver display styles and acceptance checkbox in production browsers; add backend validation and storage for uploaded files.
- Expand segment builder capabilities with nested groups, range filters for numbers/dates, and a server-side query builder. Steps: (1) Update UI to support grouped rules. (2) Implement filtering logic. (3) Expose backend query endpoint.
- For bulk SMS, add server-side credit enforcement, chunking/rate limiting with retries, and template variable parsing. Steps: (1) Verify credits on backend before sending. (2) Split sends into provider-compliant batches and retry on failures. (3) Parse variables before dispatch.
- Replace simulated credit purchase flow in `creditsService.beginUserPurchase` with a Stripe Checkout session and show transaction history on the billing page. Steps: (1) Create backend to generate Checkout sessions. (2) Redirect users to returned URL. (3) After webhooks update credits, render recent invoices in `src/pages/Settings/Billing.tsx`.
- Verify `credit_ledger` table uses columns `owner_id` and `delta`. If older columns (`user_id`, `change`) exist, rename them and migrate data. Steps: (1) Adjust table schema in Supabase SQL editor if needed. (2) Confirm new entries from the app populate `owner_id` and `delta` correctly.
- Implement server-side scheduling, delivery status tracking, and retries for SMS once a provider is integrated. Steps: (1) Use provider API/webhooks to track status. (2) Persist message logs in database. (3) Retry failed sends according to carrier guidelines.
- Improve form builder slug UX. Steps: (1) Enhance slug input to auto-generate/validate unique slugs and prevent duplicates.
  - Confirm Inter font loads in production and host locally if external requests are restricted. Steps: (1) Visit the deployed app and verify the font in browser dev tools. (2) If blocked, download the Inter font files and serve them from the app's assets directory.
- Optional: Allow forms without campaigns. Steps: (1) In the Supabase SQL editor or CLI, run `alter table public.campaign_forms alter column campaign_id drop not null;`. (2) From the project root, execute `supabase db push` to apply the migration. [i did this step, now nullable?]

- [NEW] Verify CSV import works in browsers without Web Crypto support after switch to uuid-based IDs.
  Steps:
    1. Build and deploy the app.
    2. Test Bulk Import in an older browser lacking `crypto.randomUUID` support.
    3. Confirm contact IDs are generated and import succeeds.
- [NEW] Manually verify in Supabase that imported customer rows are associated with the correct `user_id` and remove any placeholder/demo data.
  Steps:
    1. In the Supabase dashboard, open the Table editor for the `customers` table.
    2. Filter by your user ID and ensure each imported row has that `user_id` value.
    3. Delete any placeholder or demo contacts (e.g., rows named "Imported #1" or other sample data).

- [NEW] Verify `intake_add_customer` RPC executes after deployment.
  Steps:
    1. Deploy the updated app.
    2. Submit a test intake form to trigger the RPC.
    3. In Supabase, open the `customers` table and confirm the test row appears with the correct `user_id` and slug.
    4. Delete the test row once verified.

- [NEW] Apply Supabase migration `20250806050000_update_customers_phone_email.sql` for email support and phone normalization.
  Steps:
    1. From the project root, run `supabase db push` or execute the SQL file in Supabase's SQL editor.
    2. Review `customer_email_collisions` and `customer_phone_collisions` tables and resolve any duplicates per `user_id`.
    3. After resolving, delete collision tables and regenerate types: `supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts`.
- [NEW] Grant or revoke admin rights via `profiles.role`.
  Steps:
    1. In Supabase SQL editor run:
         update profiles set role = 'admin' where id = '<USER_ID>';
         update profiles set role = 'user' where id = '<USER_ID>';
- [NEW] Verify RLS policies on `profiles` allow only admins to read/update other profiles.
  Steps:
    1. In Supabase dashboard, open the `profiles` table policies.
    2. Ensure read/update policies include `auth.uid() = id` or `role = 'admin'` and test as both admin and non-admin.
- [NEW] Prep deployment for the new admin guard and Forbidden page.
  Steps:
    1. Seed at least one admin profile using the SQL above.
    2. Remove any temporary admin login links or placeholder data before launch.
    3. Test `/admin` as both admin and non-admin to confirm navigation and Forbidden messaging.
- [NEW] Apply Supabase migration `20250807090000_add_profile_approval_flags.sql` to add approval flags and tighten RLS.
  Steps:
    1. In Supabase SQL editor or via CLI, run the SQL in `supabase/migrations/20250807090000_add_profile_approval_flags.sql`.
    2. Confirm `profiles` has `is_approved`, `is_active`, and `deactivated_at` columns with defaults.
    3. Verify updated policies on `profiles`, `campaigns`, and `customers` enforce admin access and require approved/active profiles for writes.
- [NEW] Regenerate Supabase types after applying the migration.
  Steps:
    1. Execute `supabase gen types typescript --project-id <PROJECT_ID> --schema public > src/types/supabase.ts`.
    2. Commit the regenerated `src/types/supabase.ts`.
- [NEW] Review new admin user management at `/admin/users`.
  Steps:
    1. As an admin, test Approve/Prohibit/Delete/Make Admin actions and ensure toasts reflect results.
    2. In Supabase dashboard, confirm profile rows update accordingly and remove any test or placeholder accounts.

- [NEW] Review and maintain `SUPABASE_SCHEMA_SPEC.txt` after applying Supabase migrations.
  Steps:
    1. After each schema change, update the spec file and commit.

### Form Builder Metadata
- [TODO] Verify factory field mappings persist and deduplicate in saved form schema.
  Steps:
    1. Build a form with multiple factory fields including duplicates.
    2. Save the form and inspect `schema_json` to confirm only the last block per factory field remains.
- [TODO] Implement server-side handling to skip empty answers and honor `saveToLatest` during submissions.
  Steps:
    1. Update Supabase RPCs or API routes to ignore empty values and dedupe using `dataKey`.
    2. Ensure backend respects the `saveToLatest` flag when persisting customer data.
- [TODO] Replace placeholder factory badges/icons with finalized design assets.
  Steps:
    1. Provide final badge imagery or SVG.
    2. Update builder components to use the new assets.
