- [NEW] Run SQL in Supabase to create `public.customers` table with RLS policies.
  Steps:
    1. In Supabase dashboard, open the SQL editor.
    2. Execute:
       create table public.customers (
         id uuid primary key,
         user_id uuid not null references auth.users(id) on delete cascade,
         name text not null default '',
         phone text not null default '',
         location text,
         signup_date timestamptz not null default now(),
         extra jsonb not null default '{}'::jsonb
       );
       create index customers_user_id_idx on public.customers(user_id);
       alter table public.customers enable row level security;

       create policy "customers_select" on public.customers
         for select using (auth.uid() = user_id);
       create policy "customers_insert" on public.customers
         for insert with check (auth.uid() = user_id);
       create policy "customers_update" on public.customers
         for update using (auth.uid() = user_id);
       create policy "customers_delete" on public.customers
         for delete using (auth.uid() = user_id);
    3. In Table editor, confirm the `customers` table and all four policies exist.
- [NEW] Update Supabase function `intake_add_customer` to use new `customers` columns.
  Steps:
    1. In the Supabase dashboard, open the SQL editor.
    2. Execute:
       create or replace function public.intake_add_customer(payload jsonb)
       returns uuid
       language plpgsql
       as $$
       declare
         v_customer_id uuid;
         v_field_name text;
         v_field_value jsonb;
         v_field_id uuid;
       begin
         insert into customers (id, user_id, name, phone, location, signup_date, extra)
         values (
           coalesce((payload->>'id')::uuid, gen_random_uuid()),
           (payload->>'user_id')::uuid,
           coalesce(payload->>'name', ''),
           coalesce(payload->>'phone', ''),
           payload->>'location',
           coalesce((payload->>'signup_date')::timestamptz, now()),
           coalesce(payload->'extra', '{}'::jsonb)
         )
         on conflict (id) do update
           set user_id    = excluded.user_id,
               name       = excluded.name,
               phone      = excluded.phone,
               location   = excluded.location,
               signup_date= excluded.signup_date,
               extra      = excluded.extra
         returning id into v_customer_id;

         if payload ? 'custom_fields' then
           for v_field_name, v_field_value in
             select key, value from jsonb_each(payload->'custom_fields')
           loop
             insert into custom_fields (name)
             values (v_field_name)
             on conflict (name) do nothing
             returning id into v_field_id;

             if v_field_id is null then
               select id into v_field_id from custom_fields where name = v_field_name;
             end if;

             insert into customer_custom_field_values (customer_id, field_id, value)
             values (v_customer_id, v_field_id, v_field_value::text)
             on conflict (customer_id, field_id) do update
               set value = excluded.value;
           end loop;
         end if;

         return v_customer_id;
       end;
       $$;
    3. In the SQL editor, verify the function executes without errors.
- [NEW] Ensure Supabase RPC `intake_add_customer` accepts a `p_user_id` argument and inserts it into `customers.user_id`.
  Steps:
    1. In Supabase dashboard > SQL editor, modify the function signature to include `p_user_id uuid`.
    2. Use `p_user_id` in the INSERT/UPSERT statement for the `user_id` column.
    3. Deploy the updated function so RPC calls with `p_user_id` succeed.
- No manual steps required for removal of placeholder `/* FOOTER */` comment in `src/pages/Home.tsx`.
- Replace placeholder hero and patriot banner images in `src/components/home/HeroSection.tsx` and `src/components/home/PatriotBanner.tsx` with production assets. Steps: (1) Upload final images to an assets directory or CDN. (2) Update `HERO_MEDIA` and `PEOPLE_IMG` constants with the new URLs or imports. (3) Run `npm run build` to verify they load correctly.
- Replace the temporary SMS service in `src/services/smsService.ts` with a real provider (e.g., Twilio) and remove `alert` calls and localStorage logging.
- Configure production environment variables for SMS API credentials and scheduling backend.
- Clean up any demo SMS logs stored in localStorage before launch.
- Manually verify the new mobile block palette and property panel drawers on multiple real devices and screen sizes, adjusting Tailwind styles if any layout issues arise.
- Test touch drag-and-drop in the form builder on physical iOS/Android browsers to confirm sensors and styles handle mobile gestures.
  - Address npm warning about unknown `http-proxy` env config in deployment environment. Steps: (1) Remove `http-proxy` and `https-proxy` environment variables or rename to `HTTP_PROXY`/`HTTPS_PROXY`. (2) Use `npm config set proxy <url>` if a proxy is required.
  - Remove demo seed scripts (`src/dev/seed.ts` and `src/dev/seed.local.ts`) and delete any sample accounts from production. Steps: (1) Delete scripts. (2) Purge demo users.
- Ensure `.env` variables `VITE_SUPABASE_URL`, `VITE_SUPABASE_ANON_KEY`, and `VITE_PUBLIC_APP_URL` are set to production values (placeholders currently committed). Steps: (1) Edit `.env` with real URLs/keys. (2) Redeploy.
- After integrating a real SMS provider, update `src/utils/credits.ts` `DEFAULT_SMS_COST_PER_SEGMENT` and remove `src/utils/demoSMS.ts`. Steps: (1) Adjust constant to provider rate. (2) Delete file and references.
- Replace local object URL handling for image and PDF uploads in the form builder with real Supabase storage uploads and persist returned URLs in `schema_json`.
- Verify PDF waiver display styles and acceptance checkbox in production browsers; add backend validation and storage for uploaded files.
- Remove legacy `getCurrentUser` fallback in `src/routes/ProtectedRoute.tsx` once all pages rely on `useAuth`. Steps: (1) Audit remaining pages using `getCurrentUser`. (2) Delete fallback logic.
- Expand segment builder capabilities with nested groups, range filters for numbers/dates, and a server-side query builder. Steps: (1) Update UI to support grouped rules. (2) Implement filtering logic. (3) Expose backend query endpoint.
- For bulk SMS, add server-side credit enforcement, chunking/rate limiting with retries, and template variable parsing. Steps: (1) Verify credits on backend before sending. (2) Split sends into provider-compliant batches and retry on failures. (3) Parse variables before dispatch.
- Replace simulated credit purchase flow in `creditsService.beginUserPurchase` with a Stripe Checkout session and show transaction history on the billing page. Steps: (1) Create backend to generate Checkout sessions. (2) Redirect users to returned URL. (3) After webhooks update credits, render recent invoices in `src/pages/Settings/Billing.tsx`.
- Implement server-side scheduling, delivery status tracking, and retries for SMS once a provider is integrated. Steps: (1) Use provider API/webhooks to track status. (2) Persist message logs in database. (3) Retry failed sends according to carrier guidelines.
- Improve form builder slug UX. Steps: (1) Enhance slug input to auto-generate/validate unique slugs and prevent duplicates.
  - Replace the alert in `FormBuilder` error handling with a toast/snackbar component. Steps: (1) Install a toast library (e.g., react-toastify). (2) Display a toast on save failure instead of using `alert`.
  - Confirm Inter font loads in production and host locally if external requests are restricted. Steps: (1) Visit the deployed app and verify the font in browser dev tools. (2) If blocked, download the Inter font files and serve them from the app's assets directory.
- Optional: Allow forms without campaigns. Steps: (1) In the Supabase SQL editor or CLI, run `alter table public.campaign_forms alter column campaign_id drop not null;`. (2) From the project root, execute `supabase db push` to apply the migration. [i did this step, now nullable?]

- [NEW] Verify CSV import works in browsers without Web Crypto support after switch to uuid-based IDs.
  Steps:
    1. Build and deploy the app.
    2. Test Bulk Import in an older browser lacking `crypto.randomUUID` support.
    3. Confirm contact IDs are generated and import succeeds.
